相关证明可以看：https://oi-wiki.org/math/number-theory/powerful-number/

# PN筛

**积性函数**：对于所有互质的$a$和$b$，总有$f(ab)=f(a)f(b)$，则称$f$为积性函数。

**PN(power number)**：对于正整数$n$，记$n$的质因数分解为$\prod p_i^{c_i}$。 是 PN 当且仅当$\forall1<=i<=m,c_i>1$。（1也是PN）

性质1：所有 PN 都可以表示成$a^2b^3$的形式，因为大于等于2的数总能分解成$2x+3y$的形式。

**性质2： $n$以内的 PN 至多有$O(\sqrt n)$个，可以通过dfs枚举下一个质数的次数在$O(\sqrt n)$时间内找到这些PN。**



已知$f$为积性函数，求$F(n)=\sum_{i=1}^nf(i)$

通过PN筛求解的一般过程：

**1.构造积性函数$g$满足$g(p)=f(p)$，且$G(n)=\sum_{i=1}^ng(i)$能够快速求出（或者快速预处理$2\sqrt n$个有效值）**

2.构造（其实不用真的构造）$h$满足$g*h=f$，且$h(p^c)$能够快速求出，由$g*h=f$可得$h$也是积性函数

**3.其实$h$满足$h(1)=1,h(p)=0,f(p^c)=\sum_{i=0}^cg(p^i)h(p^{c-i})$即可，也可以移项递推$h(p^c)=f(p^c)-\sum_{i=1}^cg(p^i)h(p^{c-i})$**

3.5.如果你在程序里递推$h(p^c)$复杂度会是$O(\sqrt nlog(n))$的，但是实测跑不满，耗时较少。

**4.dfs求出小于等于n的PN的同时计算$h(PN)$和答案，$F(n)=\sum_{i=1}^n[i是PN]h(i)G(\lfloor \frac{n}{i} \rfloor)$**

复杂度与计算$h$和$G$的复杂度有关（有时需要预处理），两者均为$O(1)$时，总复杂度为$O(\sqrt n)$



### 2022HDU多校5-1002

$f(p^c)=\frac{p^c}{c}$，求$\frac{1}{n}\sum_{i=1}^nf(i)$,$n<=1e12$

构造积性函数$g(p^c)=p^c$,即$g(x)=x,G(x)=\frac{x(x+1)}{2}$，并求出$h$

这里先递推找规律：

| $c$  | $f(p^c)=\frac{p^c}{c}$ | $g(p^c)=p^c$ | $h(p^c)$          |
| ---- | ---------------------- | ------------ | ----------------- |
| 0    | $1$                    | $1$          | $1$               |
| 1    | $p$                    | $p$          | $0$               |
| 2    | $\frac{p^2}{2}$        | $p^2$        | $-\frac{p^2}{2}$  |
| 3    | $\frac{p^3}{3}$        | $p^3$        | $-\frac{p^3}{6}$  |
| 4    | $\frac{p^4}{4}$        | $p^4$        | $-\frac{p^4}{12}$ |
| 5    | $\frac{p^5}{5}$        | $p^5$        | $-\frac{p^5}{20}$ |

容易发现$c>=2$时$h(p^c)=-\frac{p^c}{c(c-1)}$

也可以直接推式子：

$f(p^c)=\sum_{i=0}^cg(p^i)h(p^{c-i})$

$\frac{p^c}{c}=\sum_{i=0}^cp^ih(p^{c-i})$

$\frac{1}{c}=\sum_{i=0}^c\frac{h(p^{c-i})}{p^{c-i}}=\sum_{i=0}^c\frac{h(p^{i})}{p^{i}}$

$c>=2$时：

$\frac{1}{c}-\frac{1}{c-1}=\sum_{i=0}^c\frac{h(p^{i})}{p^{i}}-\sum_{i=0}^{c-1}\frac{h(p^{i})}{p^{i}}$

$\frac{h(p^{c})}{p^{c}}=\frac{1}{c}-\frac{1}{c-1}=-\frac{1}{c(c-1)}$

$h(p^c)=-\frac{p^c}{c(c-1)}$

预处理逆元（或者记忆化h函数后）可以$O(1)$求出。

dfs出$n$以内的所有PN，在dfs过程中，对于每个PN——$x$,将$h(x)G(\lfloor \frac{n}{x} \rfloor)$累加到答案上即可。



实际代码时要注意的点：

1.质数需要处理到$\sqrt n$，可以多处理一点例如处理到$100+\sqrt{maxn}$

2.h函数只会用到PN数处的值，预处理/记忆化时，只需要存$c>=2$的$h(p^c)$，$h(p_1^{c_1}p_2^{c_2}p_3^{c_3})$之类的可以直接在dfs中通过积性函数性质$O(1)$运算。

3.满足$c>=2$且$p^c<=n$的$p^c$都是PN，所以其数量是不超过$O(\sqrt n)$的。

4.$h(p^c)$可以按质数的下标（即第几个质数） 和$c$存来省空间。

5.对于同一个n，G的有效取值会有$2\sqrt n$个，即$G(1)、G (2)...G(\sqrt n)$和$G(\frac{n}{1})、G(\frac{n}{2})...G(\frac{n}{\sqrt n})$，有时需要预处理。

6.这题部分乘法要先转__int128再乘再取模。

